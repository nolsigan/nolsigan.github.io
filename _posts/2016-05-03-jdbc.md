---
layout: post
date: 2016-05-03
title: JDBC & Code Modularization
tags: [jdbc, db, code management]
---

## JDBC

학교 데이터베이스 수업 과제로 JDBC를 통해 간단한 School information application을 만들게 되었다. 모바일 앱이나 웹 앱을 만들 때에는 주로 더 추상화된 
모듈을 쓰기 때문에 직접 JDBC를 다뤄본 적은 없었다.  
Android 같은 경우에는 지난 글에도 나온 Realm, node.js에서는 mongoose를 사용했었다. 둘 다 막 복잡한 쿼리들을 구현해본 적이 없어서 모르겠지만 
여러 schema들의 조합으로 이루어진 데이터를 한번에 얻고 싶다면 JDBC 처럼 직접 sql을 쓰는 것도 나쁘진 않을 것 같다는 생각이 든다.

<br/>

#### JDBC란?

<img src="http://1.bp.blogspot.com/-tLMCqec9dF0/VJeaTFnbwYI/AAAAAAAAGpA/sbjyPvg-aig/s1600/JDBC-Architecture.gif" alt="arch" style="width: 400px; display: block; margin: 0 auto;"/>

<br/>

java application이 db에 접근할 수 있도록 API를 제공한다고 보면 된다. String 형의 query를 작성하고 db에 날리면 ResultSet을 통해 결과값을 받게 된다.

<br/>

#### 사용법

[Outsider 님의 블로그 글][blog_outsider]

* connect

```java
/* connect to db */
public void connect() throws SQLException, ClassNotFoundException {
    
    Class.forName("com.tmax.tibero.jdbc.TbDriver");
    conn = DriverManager.getConnection("jdbc:tibero:thin:@"+IP+":"+PORT+":"+TB_SID, userid, pwd);
    
    if (conn == null) {
        System.out.println("Tibero Connection Failure");
        System.exit(-1);
    }
    System.out.println("Tibero DBConnection Success!");
}
```
API를 통해 db 서버에 접속한다. 수업에선 tibero를 사용하였고 사실 oracle이랑 완전히 API가 같아서 그냥 oracle 예시들을 보고 구현하였다.

* use query

```java
public int getStudentCredit(String id) throws SQLException {
		
    String query = "select tot_cred from student where id=?";
    
    pstmt = conn.prepareStatement(query);
    pstmt.setString(1, id);
    rs = pstmt.executeQuery();
    
    if (rs.next()) return rs.getInt(1);
    
    return -1;
}
```
String 형으로 query를 작성하고 API를 통해 dbms에 날려주면 rs를 통해 받을 수 있고 이를 next()로 넘어가며 값을 읽는다.  

next()는 query 결과물의 각 tuple을 iterate 한다고 생각하면 되고  
getString(i) or getInt(i) 등등은 해당 row의 i번째 값을 읽는 함수다.

* close

```java
/* close connection */
public void close() throws Exception {
    try {
        if (pstmt != null) pstmt.close();
        if (rs != null) rs.close();
        if (conn != null) conn.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
앱이 종료될 시에 close로 connection을 전부 닫아준다. 연결할 때와 달리 역순으로 닫는데 모두 사용이 끝난 후라면 뭘 먼저 닫든 별 상관이 
없는 듯 하다.

<br/>

## Code Modularization

요즘 들어 코딩을 할 때 코드의 간결함과 깔끔함에 신경을 쓰게 된다. 아마 그동안 수많은 삽질을 해온 덕분에 이제 프로젝트를 시작하기도 전에 코드 디자인을 
대충한다면 어떤 일(지옥)이 벌어질지 조금은 예측할 수 있게 된 것 같다.

이번 프로젝트도 비교적 크기가 작지만 깔끔하게 구현을 하고 싶어서 최대한 reasonable 하게 모듈화를 하려고 노력했다. 프로젝트를 간단히 설명하자면 UI를 통해 
input을 받으면 user가 누군지, 어떤 input을 받았는지에 따른 적절한 query를 수행해서 결과를 다시 UI로 제공하면 됐다.

> *Code Structure*
>
> Control.java : UI 담당
>
> Login.java : Login 담당
>
> DBConnection.java : DB 관련 작업 담당
>
> 등등...

고민 됐던 점은 DBConnection에서 완전히 query 관련한 일만 처리하게 하고 싶었는데 그렇게 하자니 모듈간에 데이터를 주고 받는 overhead가 너무 커졌다.
query 결과를 주면 그걸 다른 모듈이 받아서 다시 순환하면서 DB 모듈의 함수를 부르고.. 또 주고.. 받고..

깔끔하게 짜려다가 느려지고 더 복잡해질 수도 있겠다는 생각이 들었다. 이런 경우에 어떻게 해야할지 잘 모르겠는데 지금 생각으로는 두 가지로 나눠서 생각해야 할 것 같다.

* Scalability가 중요한 프로젝트는 모듈화에 초점을 맞추고 overhead, redundancy를 좀 감안한다
* Performance가 중요한 부분은 반대로 overhead, redundancy를 최대로 줄인다

다른 open source 프로젝트들은 어떻게 하는지 더 살펴봐야겠다.



[blog_outsider]: https://blog.outsider.ne.kr/6